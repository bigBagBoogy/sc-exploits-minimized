// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {HandlerStatefulFuzzCatches} from "src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {MockUSDC} from "test/mocks/MockUSDC.sol";
import {YeildERC20} from "test/mocks/YeildERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Handler} from "test/invariant-break/handler/Handler.t.sol";

contract AttemptedBreakTest is StdInvariant, Test {
    HandlerStatefulFuzzCatches public hsf;
    MockUSDC public mockUSDC;
    YeildERC20 public yeildERC20;
    Handler public handler;
    IERC20[] supportedTokens;

    address user = makeAddr("user");
    uint256 startingAmount;

    function setUp() public {
        // So, the constructor of HandlerStatefulFuzzCatches takes an array of supported
        // ERC20 tokens. For this test to work we are going to need the mocks.
        // The test will fail if we don't do this.
        // these ERC20 don't exist here otherwise
        // we need both used erc20 mocks AND the IERC20 contract from openzeppelin
        // because the contract we're testing uses Implementation of the {IERC20} interface
        // 1st we need to load the `IERC20[]` with the 2 mockTokens
        vm.startPrank(user);
        yeildERC20 = new YeildERC20(); // deploying this automatically mints to user some tokens
        mockUSDC = new MockUSDC();
        startingAmount = yeildERC20.INITIAL_SUPPLY();
        mockUSDC.mint(user, startingAmount); // this seems a super weird way to mint the same amount of mockUSDC tokens as the yeildERC20.
        vm.stopPrank();

        supportedTokens.push(yeildERC20);
        supportedTokens.push(mockUSDC);

        hsf = new HandlerStatefulFuzzCatches(supportedTokens);
        // targetContract(address(hsf));
        handler = new Handler(hsf, mockUSDC, yeildERC20, user);

        // Now we need to make an array of funcions to call in the fuzz test.
        // in foundry, we call these selectors.

        bytes4[] memory selectors = new bytes4[](4);
        selectors[0] = handler.depositYeildERC20.selector;
        selectors[1] = handler.depositMockUSDC.selector;
        selectors[2] = handler.withdrawYeildERC20.selector;
        selectors[3] = handler.withdrawMockUSDC.selector;

        targetSelector(FuzzSelector({addr: address(handler), selectors: selectors}));
        targetContract(address(handler));
    }

    // so far setUp. Now how do we test: INVARIANT: Users must always be able to withdraw the exact balance amount.

    // *****GOTCHA: Patrick only pranks the withdraw function. Why? Should we not arrange to first prank the deposit and then the withdraw?
    // It seems that the random sequence of test calls executed by foundry will in
    // itself create the circumstances where funds are deposited.
    // So, we don't need to arrange the prank deposit.

    function statefulFuzz_testWithdrawExactAmountHandlerMaarten() public {
        vm.startPrank(user);
        // hsf.depositToken(yeildERC20, 10); // not necessary -> see GOTCHA
        // hsf.depositToken(mockUSDC, 10);

        hsf.withdrawToken(yeildERC20); // no amount, because we always withdraw the exact balance amount
        hsf.withdrawToken(mockUSDC);
        vm.stopPrank();

        assert(mockUSDC.balanceOf(address(hsf)) == 0);
        assert(yeildERC20.balanceOf(address(hsf)) == 0);

        assert(yeildERC20.balanceOf(user) == startingAmount);
        assert(mockUSDC.balanceOf(user) == startingAmount);
    }

    // so far setUp. Now how do we test: INVARIANT: Users must always be able to withdraw the exact balance amount.
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    // for debugging purposes:
    function testStartingAmountTheSame() public {
        // assert(startingAmount == yeildERC20.balanceOf(user));
        // assert(startingAmount == mockUSDC.balanceOf(user));
        assertEq(startingAmount, yeildERC20.balanceOf(user));
        assertEq(startingAmount, mockUSDC.balanceOf(user));
    }
}
