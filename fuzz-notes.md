stateless fuzz test can be run with just the import of Test.sol

for running stateful tests we need to import StdInvariant _and inherit_ it too!

```javascript
import {StdInvariant} from "forge-std/StdInvariant.sol";

contract StateFullFuzzCatchesTest is StdInvariant, Test {}
```
This foundry library holds the methods like: `address[] private _targetedContracts;`
and many more, to nail and narrow down the test params

function `targetContract` will let you tell foundry what contract to do stateful
fuzzing tests on. 

### to do this:
In the setUp function, call the targetContract() and pass in the contract:
```javascript
        targetContract(address(auditContract));
```

Foundry is actually smart enough to read this target contract and go; ok, I can call all the state variables (yes, public variables have functions) and functions in here.
It will call the randomly, with random args.

## in foundry.toml:
[depth = 32] means the anount of things (functions) foundry calls in sequence,
before resetting and starting a new run (think new balloon).

## If you're bugged by errors that are not related to your invariant breaking,
like in the course the arithmetic overflow, you can set:
 `fail_on_revert = false`

The stateFULL test in the course finds the invariant-break, where the
stateLESS test does not, beacause of the sequence tried by foundry:
1. in a particular run it calls: `StatefulFuzzCatches::changeValue(0)` (so args = 0)
2. then it chooses to call `StatefulFuzzCatches::doMoreMathAgain` with this value (0)
making the output of this function 0

## Next up we test on the `HandlerStatefulFuzzCatches` contact.
When initially fuzzing we get almost 100% reverts:  `FAIL. Reason: custom error`
`HandlerStatefulFuzzCatches__UnsupportedToken()`

Turns out, foundry tries our functions will all these random ERC20 addresses, all
of whom are not supportedTokens, hence the custom revert.

We need to limit the input to just the tokens that are supported.
otherwise we run into _"path explosion"_ where there are too many possible paths, 
and the fuzzer finds nothing.

We should not however, now limit the tokens to ONLY the 2 allowed tokens either.
Doing this would not take scenario's into account where the token actually IS an unsupported Token.

One other thing we missed in the initial run of the fuzz test is running the
`approve()` function _before_ calling `deposit()`

### _on top of all that:_
The fuzzer also fuzzed the `user`. In our test setup, only 1 user ("user") actually
has tokens, but foundry calls all the functions with randomly generated user-addresses,
making all those calls fail aswell.


# We write a handler contract that will act as a "wrapper" around the invariant.t.sol test
Here we will "bound" the range of inputs the fuzzer will try.
The Handler contract does NOT have a setUp(). 
The Handler contract needs to import the contract-to-be-tested + possibly mocks
The Handler contract needs to import Test from std.  Others might import various more
specific modules "children" of Test.sol, but we can just import the "parent" Test.sol.


in invariant.t.sol we now also instantiate this handler:
```javascript
handler = new Handler(hsf, mockUSDC, yeildERC20, user);
```
and also in invariant.t.sol we select the functions (that we wrote in Handler.t.sol), that
should be called by the fuzzer:
```javascript
   bytes4[] memory selectors = new bytes4[](4);
        selectors[0] = handler.depositYeildERC20.selector;
        selectors[1] = handler.depositMockUSDC.selector;
        selectors[2] = handler.withdrawYeildERC20.selector;
        selectors[3] = handler.withdrawMockUSDC.selector;

        targetSelector(FuzzSelector({addr: address(handler), selectors: selectors}));
        targetContract(address(handler));
```
When running the test now, we find an error:  ```[FAIL. Reason: custom error e450d38c```
```[11444] HandlerStatefulFuzzCatches::withdrawToken(YeildERC20: [0x7BD1119CEC127eeCDBa5DCA7d1Bd59986f6d7353])
    │   ├─ [3002] YeildERC20::transfer(user: [0x6CA6d1e2D5347Bfab1d91e883F1915560e09129D], 997430881266105103636704 [9.974e23])
    │   │   └─ ← ERC20InsufficientBalance(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f, 997430881266105103636174 [9.974e23], 997430881266105103636704 [9.974e23])
    │   └─ ← ERC20InsufficientBalance(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f, 997430881266105103636174 [9.974e23], 997430881266105103636704 [9.974e23])
    └─ ← ERC20InsufficientBalance(0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f, 997430881266105103636174 [9.974e23], 997430881266105103636704 [9.974e23])
```
High level reason our invariant broke: We try to withdraw the owed yeildERC20
   tokens, but not the entire balance reaches us/user.
   
## turns out yeildERC20 is a weird token: 
     * Every 10 transactions, we take a fee of 10% and send it to the owner.
Learn more on weird ERC20's:  https://github.com/d-xo/weird-erc20
https://secure-contracts.com/development-guidelines/token_integration.html

