stateless fuzz test can be run with just the import of Test.sol

for running stateful tests we need to import StdInvariant _and inherit_ it too!

```javascript
import {StdInvariant} from "forge-std/StdInvariant.sol";

contract StateFullFuzzCatchesTest is StdInvariant, Test {}
```
This foundry library holds the methods like: `address[] private _targetedContracts;`
and many more, to nail and narrow down the test params

function `targetContract` will let you tell foundry what contract to do stateful
fuzzing tests on. 

### to do this:
In the setUp function, call the targetContract() and pass in the contract:
```javascript
        targetContract(address(auditContract));
```

Foundry is actually smart enough to read this target contract and go; ok, I can call all the state variables (yes, public variables have functions) and functions in here.
It will call the randomly, with random args.

## in foundry.toml:
[depth = 32] means the anount of things (functions) foundry calls in sequence,
before resetting and starting a new run (think new balloon).

## If you're bugged by errors that are not related to your invariant breaking,
like in the course the arithmetic overflow, you can set:
 `fail_on_revert = false`

The stateFULL test in the course finds the invariant-break, where the
stateLESS test does not, beacause of the sequence tried by foundry:
1. in a particular run it calls: `StatefulFuzzCatches::changeValue(0)` (so args = 0)
2. then it chooses to call `StatefulFuzzCatches::doMoreMathAgain` with this value (0)
making the output of this function 0

## Next up we test on the `HandlerStatefulFuzzCatches` contact.
When initially fuzzing we get almost 100% reverts:  `FAIL. Reason: custom error`
`HandlerStatefulFuzzCatches__UnsupportedToken()`

Turns out, foundry tries our functions will all these random ERC20 addresses, all
of whom are not supportedTokens, hence the custom revert.

We need to limit the input to just the tokens that are supported.
otherwise we run into _"path explosion"_ where there are too many possible paths, 
and the fuzzer finds nothing.

We should not however, now limit the tokens to ONLY the 2 allowed tokens either.
Doing this would not take scenario's into account where the token actually IS an unsupported Token.

One other thing we missed in the initial run of the fuzz test is running the
`approve()` function _before_ calling `deposit()`

### _on top of all that:_
The fuzzer also fuzzed the `user`. In our test setup, only 1 user ("user") actually
has tokens, but foundry calls all the functions with randomly generated user-addresses,
making all those calls fail aswell.